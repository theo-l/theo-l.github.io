:data-transition-duration: 2000
:skip-help: true

.. title: Presentation Title

----

Hacking python class
=======================

What is a class?
----------------


1. A name to refer the class object: *Employee*
...................................................

2. A list of parent class objects: *(Person, Worker)*
......................................................

3. A collection of attributes: *[public_value, _fake_private_attribute, __private_attribute]*
.................................................................................................

4. A collection of methods: *[instance_method, class_method, static_method, builtin_method]*
..................................................................................................

5. Class inheritance resolution: *mro*
........................................

6. Class design patterns: *[is-a, has-a, proxy]*
...................................................

7. Class from scratch: *[type(classname, (supers,), attributes)]*
.....................................................................


----

A simple python class demo
============================

.. code:: python

    class Employee:

        # declared class attributes
        employee_count = 0
        employee_position_count = {}

        # A fake private attribute by python convention
        _some_private_value='some private value'

        # declared some real private attribute, which can not access by instance/class directly
        __private_value = 'private'

        __slots__ = ['name', 'age', 'position', '_value'] # A python limited attribute access protocol

        def __new__(cls, *args, **kwargs): # Where create the instance object(self)
            return object.__new__(cls)

        def __init__(self, name: str = None, age: int = 0, position: str = None):

            # Instance's attributes
            self.name = name
            self.age = age
            self.position = position

            # Access class's attribute
            Employee.employee_position_count.setdefault(position, 0)
            Employee.employee_position_count[position] += 1
            Employee.employee_count += 1
            self._value = 'test'

        @property
        def value(self): # a kind of attribute based on **descriptor** protocol
            return self._value

        @value.setter
        def value(self, value):
            self._value = value

        def work(self): # instance method
            print(f'{self.name} is working now!')

        @classmethod
        def get_employee_count(cls): # class method
            print(f'Total employee: {cls.employee_count}')

        @staticmethod
        def get_employee_position_count(position: str = None): # static method
            if not position:
                print(f'Employee in {position}: {Employee.employee_position_count[position]}')
            print(f'Employee in {position}: {Employee.employee_position_count.get(position, 0)}')

        def __str__(self): # Instance & built-in method
            return f'({self.name} : {self.age} : {self.position})'

----


Class attributes collection
===========================

#. Attribute categories
    #. public attribute
    #. private attribute
    #. class attribute
    #. descriptor managed attribute
    #. instance attribute


#. Class/instance attribute access

    #. __getattribute__(self, item): Any kind of attribute access
    #. __getattr__(self, item): Access non-exist(declared) attribute
    #. __setattr__(self, key, value): Set instance attribute
    #. descriptor access: get/set/del descriptor managed attribute

----

Work with class's attribute
============================

.. code:: python

    class NameDescriptor:

        def __init__(self, value):
            print(f'Before init descriptor attribute value: {value}')
            self._value = value
            print(f'After init descriptor attribute value: {value}\n')

        def __get__(self, instance, klass):
            print(f'Before getting attribute in descriptor: <{self.__class__.__name__}>.__get__')
            result = self._value
            print(f'After getting attribute in descriptor: <{self.__class__.__name__}>.__get__\n')
            return result

        def __set__(self, instance, value):
            print(f'Before setting attribute in descriptor: <{self.__class__.__name__}>.__set__')
            self._value = value
            print(f'After setting attribute in descriptor: <{self.__class__.__name__}>.__set__\n')

    class EmployeeAttributeDemo:

        public_value = 'public'
        _fake_private_value = 'fake private value'  # python convention private attribute
        __real_private_value = 'not really a private value'  # real private attribute(which is not really private)
        name = NameDescriptor('alice')

        def __init__(self, instance_value):
            self.instance_value = instance_value

        def __setattr__(self, key, value):
            print(f'Before setting value of <{key}> => <{value}> in __setattr__')
            super(EmployeeAttributeDemo, self).__setattr__(key, value)
            print(f'After setting value of <{key}> => <{value}> in __setattr__ \n')

        def __getattr__(self, item):
            print(f'Before getting value of <{item}> in __getattr__')
            if item == 'age': return 25
            result = super(EmployeeAttributeDemo, self).__getattr__(item)
            print(f'After getting value of <{item}> in __getattr__ \n')
            return result

        def __getattribute__(self, item):
            print(f'Before getting value of <{item}> in __getattribute__')
            result = super(EmployeeAttributeDemo, self).__getattribute__(item)
            print(f'After getting value of <{item}> in __getattribute__\n')
            return result

----

Class methods collection
========================

What is a Python class method ?
-------------------------------

A class method is a function declared inside the declaration of class object.

What is the difference between method & function ?
--------------------------------------------------

#. A function is declared outside of a class(which does not rely on class)
#. A method is declared inside a class (which is relies on class)


Class method categories
----------------------------------------------
    #. Class methods: (**@classmethod**)
    #. Static methods: (**@staticmethod**)
    #. Instance methods: method(self, \*args, \*\*kwargs)
    #. built-in methods: (__new__ / __init__)

----


Class builtin methods overview
========================

#. Constructor methods overload(__new__/__init__)

#. With context protocol overload(__enter__/__exit__)

#. If context protocol overload(__bool__/__len__)

#. For loop iteration protocol overload(__next__/__iter__)

#. Builtin operator overload(__add__/__iadd__)

----


Class inheritance
=======================

#. Default parent: **object**
#. Class Methods resolution order

----


Class application patterns
========================
#. Is-a pattern
#. Has-a pattern
#. Proxy pattern


----

Back to the origin
========================
#. Which elements a class has?
#. Create a class object from scratch

----

Meta class in brief
========================
#. What is a meta class and usage
#. A step more into type function
#. Create meta class
