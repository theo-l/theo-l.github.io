<!doctype html>

<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Hacking python decorators| by theol.liang@gmail.com</title>
    
    <meta name="description" content="Hacking python decorators presentations in Markdown" />
    <meta name="author" content="Liang Guisheng" />
    <link rel="stylesheet" href="../../extras/highlight/styles/github.css">

    <link href="css/markdown-slides.css" rel="stylesheet" />
    <link href="css/devopsy.css" rel="stylesheet" />
    <link href="css/effects.css" rel="stylesheet" />
    <link href="css/custom.css" rel="stylesheet" />

</head>

<body class="impress-not-supported">
<div class="fallback-message">
    <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this presentation.</p>
    <p>For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.</p>
</div>

<div id="impress" data-transition-duration="1000">

<div class="step slide markdown" data-rel-x="0" data-rel-y="900">

# Hacking python decorators

Liang Guisheng

theol.liang@gmail.com

-----

# 1. Challenges

* 1.1 How we mark the an object be public for later use?

        def public_function(): pass
        class PublicClass: pass
        public_instance = PublicClass()

* 1.2 How we track the invocation of a callable object?
        
        def tracked_function(): print('calling tracked function!')
        class TrackedClass:
            def __init__(self):
                print('calling tracked class!')

-----

# 2. Mark public1 
    

        def public_function(): pass # a function object 
        class PublicClass:pass # a class object 
        public_instance = PublicClass() # an instance object 
        public_instance.__name__ = 'public_instance' # just for demo later use
        
        def mark_public(obj):
            obj.public = True
            return obj 
        
        def request(obj):
            if getattr(obj, 'public', False):
                print(f'PUBLIC OBJECT:<{obj.__name__}>')
            else:
                print(f'****NOT ALLOWED****:non public object: <{obj.__name__}>')

        if __name__ == "__main__":
            request(public_function) 
            request(PublicClass)
            request(public_instance)
        
            print()
            public_function1 = mark_public(public_function) 
            PublicClass1 = mark_public(PublicClass)
        
            request(public_function1) 
            request(PublicClass1)
            request(public_instance)
        

-----

# 3. Mark public2


        def mark_public(obj):
            obj.public = True
            return obj 
        
        @mark_public
        def public_function():pass
        
        @mark_public
        class PublicClass:pass
        
        public_instance = PublicClass()
        public_instance.__name__ = 'public_instance' # Just for demo
        
        def request(obj):
            if getattr(obj, 'public', False):
                print(f'PUBLIC METHOD:<{obj.__name__}>')
            else:
                print(f'****NOT ALLOWED****:non public object: <{obj.__name__}>')
        
        if __name__ == "__main__":
            print('-'*50, '\n') 
            request(public_function) 
            request(PublicClass)
            request(public_instance)
            print('-'*50, '\n') 

-----
# 4. Tracking call1 

        def tracker(obj):
            def tracked_obj(*args, **kwargs):
                print(f'\n****Starting call <{obj.__name__}>!')
                result = obj(*args, **kwargs)
                print(f'****Finihsed call <{obj.__name__}>!')
                return result
            return tracked_obj
        
        def tracked_function():
            print('"caling tracked function!"')
        
        class TrackedClass:
            def __init__(self):
                print('"calling tracked class"')
        
        if __name__ == "__main__":
            tracked_function() # before track the object
            TrackedClass()
        
            tracked_function = tracker(tracked_function) # track the object
            TrackedClass.__init__ = tracker(TrackedClass.__init__)
        
            tracked_function() # after track the object
            TrackedClass()

-----
# 5. Tracking call2

        def tracker(callable):
        
            def tracked_callable(*args, **kwargs):
                print(f'\n****Starting call <{callable.__name__}>!')
                result = callable(*args, **kwargs)
                print(f'****Finihsed call <{callable.__name__}>!')
                return result
        
            return tracked_callable
        
        @tracker
        def tracked_api():
            print('"caling tracked api!"')
        
        if __name__ == "__main__":
            print('-'*50)
            tracked_api() # call the decorated object
            print('-'*50)

-----
# 6. Old VS new
        

        @mark_public
        def public_api():
            pass

        # EUQALS TO 

        def public_api():
            pass

        public_api = mark_public(public_api)


        #-------------------


        @tracer
        def tracked_api():
            pass

        # EQUALS TO 
        def tracked_api():
            pass
        tracked_api = tracer(tracked_api)
-----
# 7. What is decorator?         

1. As we saw above, a decorator is just a simple **callable object**, which accept a **callable object** and return a **callable object**

        def mark_public(callback): # mark_public is a decorator object
            ...
            return callback # can be the original callback or some else

2. The effect of use decorator is just a simple invocation of the **decorator** object, which the input parameter is the decorated **callable object**, and return another **callable object** to the decoratored object's name   
        
        @mark_public
        def public_api(): # using decorator 
            pass

        # ---- same as ----
        public_api = mark_public(public_api) # using function call

-----
# 8. What is decorator?

* So, decorator is just a simple protocol as bellow:

        #           mark_public
        #              ^
        #              |
        callable = callable(callable)
        #   |                   |
        #   v                   v
        # public_api         public_api
        #               

        # SO we can extend this equation to 
        callable = callable(callable(callable))

        # Also

        callable = callable(callable(callable(callable.....)))
-----
# 9. Why decorator? 

* Decorators has an explicit syntax which makes them easier to spot than helper function call 

* Decorators are applied once when the subject function/class object, no need extra code

-----
# 10. Why not decorator?

* Decorator may change the type of decorated object, which return a wrapped object, not the original one

* Decorator introduced extra invocations


-----
# 11. Create decorator, how? 

* How to create decorator object?

* As above described, **decorator** is just a **callable object** satisfied the simple protocol of:

        callable = callable(callable) 

* In **Hacking python class**, we learned that in python we have 4 types of **callable objects**, so we can create decorator in 4 types.
 * Decorator function object 
 * Decorator class object 
 * Decorator method object 
 * Decorator instance object 


-----
# 12. Use decorator, Where?

* Since when we use decorator, the decorator will manage the object(callable) defined in the following. In this sence, we can apply decorator to 3 places: **function**, **class**, **method**. But since instance call is implemented by the **builtin** class method **__cal__**, so we can apply a decorator to an instance object through **__call__** builtin method decoration.

* 4 places where we can apply decorator 
 * function object
 * class object 
 * method object 
 * instance callable object 


-----
# 13. Decorator function 

        
        def decorator_function(obj):
            obj.decorator_type = 'function'
            return obj

        @decorator_function
        def function_decorated():
            pass


        def decorator_type_detector(obj):
            print(f'obj: <{getattr(obj,"__name__",obj.__class__.__name__ )}>',
            f' decorator type: <{getattr(obj, "decorator_type", "unknow decorator type").upper()}>')


        if __name__ == "__main__":
            decorator_type_detector(function_decorated)


-----
# 14. Decorator class


        class decorator_class:
            def __init__(self, obj=None):
                if obj:
                    self.obj = obj
                    self.decorator_type = 'class'

        @decorator_class
        def class_decorated():
            pass

        if __name__ == "__main__":
            decorator_type_detector(class_decorated)
-----
# 15. Decorator method


        class decorator_class:

            def decorator_method(self, obj):
                obj.decorator_type ='method'
                return obj

        instance = decorator_class()

        @instance.decorator_method
        def method_decorated():
            pass

        if __name__ == "__main__":
            decorator_type_detector(method_decorated)
-----
# 16. Decorator instance


        class decorator_class:

            def __call__(self, obj):
                obj.decorator_type ='method'
                return obj

        instance = decorator_class()

        @instance
        def instance_decorated():
            pass

        if __name__ == "__main__":
            decorator_type_detector(instance_decorated)
-----
# 17. Where use decorator?

        import types
        def general_decorator(obj):
            if isinstance(obj, type):
                obj.applied_to = 'class'
            if isinstance(obj, types.FunctionType):
                if 'function' in obj.__name__:
                    obj.applied_to = 'function'
                elif 'method' in obj.__name__:
                    obj.applied_to = 'method'
                elif obj.__name__ == '__call__':
                    obj.applied_to = 'instance'
            return obj 
        
        @general_decorator
        def decorated_function():pass
        @general_decorator
        class decorated_class():
            @general_decorator
            def decorated_method():pass
            @general_decorator
            def __call__(self, *args, **kwargs):
                self.decorated_instance()
        
        def detect_decorator_place(obj):
            print(f'Decorator applied to <{getattr(obj, "applied_to").upper()}>:[{obj.__name__}]')
        
        if __name__ == "__main__":
            detect_decorator_place(decorated_function)
            detect_decorator_place(decorated_class)
            detect_decorator_place(decorated_class.decorated_method)
            detect_decorator_place(decorated_class.__call__)
-----
* Image how can we create a system to manage all Truckpaders without use class?

  * Every Truckpader has state informations including: *name*, *position* 
  * Every Truckpader has actions including: *work()*
  * The whole number of employees
  * Implement some features with a group of truckpaders: **to_task(\*truckpaders)**

-----

# 2. TPHRS
## Truckpader Human Resource System

        EMPLOYEE_COUNT = 0
        def build_truckpader(name, position):
            global EMPLOYEE_COUNT
            EMPLOYEE_COUNT += 1
            return {'name':name, 'posstion':position}

        def work(truckpader): # make client easy to use with truckpader usage  
            position = truckpader.get('position')
            if position == 'android':
                print(f'{truckpader["name"]} is doing some KJ')
            elif position == 'frontend': 
                print(f'{truckpader["name"]} is doing some HCJ')
            elif position == 'backend':
                print(f'{truckpader["name"]} is doing some PR')
            else:
                print(f'Unkown truckpader position')
        
        def do_task(*truckpaders):
            for truckpader in truckpaders:
                work(truckpader)
        

-----
# 3. How TPHRs Works?

        if __name__ == '__main__':
            # create an data struct object *actually is a instance of dict*
            liang = build_truckpader('liang', 'backend')
            parazinho = build_truckpader('parazinho', 'android')
            paulinha = build_truckpader('paulinha', 'frontend')

            work(liang) #>>> 'liang is doing some PR'
            work(parazinho) #>>> 'parazinho is doing some KJ'
            work(paulinha) #>>> 'paulinha is doing some HCJ'

            do_task(*[liang, parazinho, paulinha]) # finish task together

-----
# 4. Challenges
## Now Truckad is growing up, and our system need more features

## what we can do to make our TPHRS support this? 


-----
# 5. Extends **work** function 
## Now we have **po**, **infra**, **bi**

        def work(truckpader): # make client easy to use with truckpader usage  
            position = getattr(truckpader, 'position')
            if position == 'android':
                print(f'{truckpader["name"]} is doing some KJ')
            elif position == 'frontend': 
                print(f'{truckpader["name"]} is doing some HCJ')
            elif position == 'backend':
                print(f'{truckpader["name"]} is doing some PR')
            elif position == 'po':
                print(f'{truckpader["name"]} is doing plaining')
            elif position == 'infra':
                print(f'{truckpader["name"]} is doing maintenance')
            elif position == 'bi':
                print(f'{truckpader["name"]} is doing statistics')
            else:
                print(f'Unkown truckpader profssion')

-----
# 6. Extended system works

        if __name__ == '__main__':
            # create an data struct object *actually is a instance of dict*
            liang = build_truckpader('liang','backend')
            parazinho = build_truckpader('parazinho','android')
            paulinha = build_truckpader('paulinha','frontend')
            ale = build_truckpader('ale','po')
            victor = build_truckpader('victor','infra')
            gabriel = build_truckpader('gabriel','bi')

            work(liang) #>>> 'liang is doing some PR'
            work(parazinho) #>>> 'parazinho is doing some KJ'
            work(paulinha) #>>> 'paulinha is doing some HCJ'
            work(ale)
            work(victor)
            work(gabriel)

            do_task(*[liang, paraziho, paulinha, ale, victor, gabriel]) # finish task together
-----

# 7. **TPHRS** with OOP/Class

Use class to represent system object

        class Employee:
            def __init__(self, name, position):
                self.name = name 
                self.position = position
            def work(self):
                pass
        class Backend(Employee):
            def __init__(self, name):
                super().__init__(name, 'backend')
            def work(self):
                print(f'{self.name} is doing PR')
        class Android(Employee):
            def __init__(self,name):
                super().__init__(name, 'frontend')
            def work(self):
                print(f'{self.name} is doing KJ')
        class Frontend(Employee):
            def __init__(self,name):
                super().__init__(name, 'frontend')
            def work(self):
                print(f'{self.name} is doing HCJ')

-----

# 8. TPHRS Work with class

Apply system objects to finish some tasks

        class Service:
            def work(self, employees:List[Employee]=None):
                employees = employees or []
                for employee in employees:
                    employee.work()

        if __name__ == '__main__':
            liang = Backend('liang')
            parazinho = Android('parazinho')
            paulinha = Frontend('paulinha')

            liang.work()
            parazinho.work()
            paulinha.work()

            review = Service()
            review.work([liang, parazinho, paulinha])

-----

# 9. Function VS Class

* Inheritance
* Easy extend
* Reuse code
* More intuitive

-----

# 10. Review class 

    # 1. Parent class: object
    class Employee(object):
    # 2. Class name: Employee

        # 3. Class attributes
        name = None
        position = None

        # 4. builtin methods
        def __init__(self, name,  position):

            # 5. instance attributes
            self.name = name 
            self.position = position

        # 6. user defined methods
        def work(self):
            pass


-----
# 11. Attribute Overview

    class DescriptorAttr:
        def __init__(self, value=None):
            self._value = value

        def __get__(self, instance, klass):
            return self._value

        def __set__(self, instance, value):
            self._value = value

    class Employee(object):
        public_attr = 'public value'
        _fake_private_attr = 'fake private value'
        __private_attr = 'not really private value'
        descriptor_attr = DescriptorAttr('descriptor value')

        def __init__(self, name=None):
            self.name = name

    if __name__ == '__main__':
        alice = Employee('alice')
        print(alice.name)
        print(alice.public_attr)
        print(alice._fake_private_attr)
        print(alice.descriptor_attr)
        print(alice.__private_attr) # cause error

-----

# 12. Instance attribute 

        class Employee:
            def __init__(self, name):
                self.name = name # initiate instance's attribute

            def __getattribute__(self, item):
                print(f'--------Access instance attribute: <{item}> in Employee.__getattribute__!\n')
                return super(Employee, self).__getattribute__(item)

            def __getattr__(self, item): # mock 'age' as non initiated instance attribute
                print(f'--------Access instance attribute: {item} in Employee.__getattr__!\n')
                return 25 if item == 'age' else super(Employee, self).__getattr__(item)

            def __setattr__(self, key, value):
                print(f'--------Set instance attribute: <{key}>=<{value}> in Employee.__setattr__!\n')
                super(Employee, self).__setattr__(key, value)

        if __name__ == '__main__':
            alice = Employee('alice')  
            print(alice.name) # access defined instance attribute
            print(alice.age) # access non-defined instance attribute
            print(alice.hello()) # demo access non-defined method

-----
# 13. Class attribute 

        class Meta(type):
            def __getattribute__(self, item):
                print(f'>>>>>>>>Access class attribute: {item} in Meta.__getattribute__!\n')
                return super(Meta, self).__getattribute__(item)

            def __getattr__(self, item): # mock 'age' as non initiated class attribute 
                print(f'>>>>>>>>Access class attribute: {item} in Meta.__getattr__!\n')
                return 25 if item == 'age' else super(Meta, self).__getattr__(item)
                
            def __setattr__(self, key, value):
                print(f'>>>>>>>>Set class attribute: <{key}> = <{value}> in Meta.__setattr__!\n')
                super(Meta, self).__setattr__(key, value)


        class Employee(metaclass = Meta):
            count = 0
            def __init__(self, name):
                self.name = name
                Employee.count+=1

        if __name__ == '__main__':
            alice = Employee('alice')  
            print(Employee.count) # access defined class attribute 
            print(Employee.age) # access non-defined class attribute
-----

# 14. Descriptor attribute

        class DescriptorAttr:
            def __init__(self, value=None):
                print(f'--------Init attribute value:<{value}> in DescriptorAttr.__init__')
                self._value = value
        
            def __get__(self, instance, klass):
                print(f'--------Before access attribute value:<{self._value}> in DescriptorAttr.__get__')
                result = self._value
                print(f'--------After access attribute value:<{self._value}> in DescriptorAttr.__get__')
                return result
        
            def __set__(self, instance, value):
                print(f'--------Before set attribute value:<{value}> in DescriptorAttr.__set__')
                self._value = value
                print(f'--------After set attribute value:<{value}> in DescriptorAttr.__set__')
        
        class Employee:
            name = DescriptorAttr('truckpader')
        
        if __name__ == "__main__":
            truckpader = Employee()
            truckpader.name = 'alice'
            print(truckpader.name)
-----
# 15. Method Overview

    class Employee:
        count = 0
        def __init__(self, name):
            self.name = name
            Employee.count += 1
        @classmethod
        def get_count(cls): # class method
            return f'Created: {cls.count} {cls.__name__}'
        @staticmethod
        def get_count2(): # static method
            return Employee.get_count()
        def work(self): # user-defined method
            print(f'{self.name} is working!\n')
        def __str__(self): # builtin special method
            return f'<Truckpad Employee: {self.name}>'
        def __call__(self, *args, **kwargs):
            return self.work()

    if __name__ == '__main__':
        alice = Employee('alice')
        bob = Employee('bob')
        print(Employee.get_count())  # call CLASS method
        print(alice.get_count())  # call CLASS method
        print(Employee.get_count2())  # call STATIC method
        print(alice.get_count2())  # call STATIC method
        # Employee.work() # call USER DEFINED method
        alice.work()  # call USER DEFINED method
        print(alice)  # call BUILTIN method
        alice()  # call INSTANCE directly

-----
# 16. 4 Callable objects

1. Function object 

        def function_object():
            print('calling function object')

2. Class object 
3. Method object 

        class ClassObject:
            def __init__(self):
                print('calling class object')
            def method_object (self):
                print('calling method object')
            def __call__(self, *args, **kwargs):
                print(f'calling instance object')

4. Instance object
        
        instance_object = ClassObject()
        instance_object()

-----

# 17. Builtin method
## 17.1 Index & Slice

        class Indexer:
            def __init__(self, value=None):
                self.value = value or []

            def __index__(self):
                return 127

            def __getitem__(self, item):
                print(f'******** Access index: {item}')
                return self.value[item]

            def __setitem__(self, key, value):
                print(f'******** Set <{key}> = <{value}>!')
                self.value[key] = value


        if __name__ == '__main__':
            indexer = Indexer([1, 2, 3, 3, 4, 5])
            print(indexer[0])
            print(indexer[0:2])

            indexer[0] = 100
            indexer[0:2] = 50, 200, 300
            print(indexer.value)

            print(hex(indexer))

-----
# 17. Builtin method

## 17.2 Iterator

        class Iterator:
            def __init__(self, value):
                self.data = value
            def __iter__(self):
                print(f'iter=>', end='')
                self.ix = 0
                return self
            def __next__(self):
                print(f'next:', end='')
                if self.ix == len(self.data):
                    raise StopIteration('iteration finished')
                item = self.data[self.ix]
                self.ix += 1
                return item
            def __getitem__(self, item): # Fallback
                print(f'get[{item}]:', end='')
                return self.data[item]
        if __name__ == '__main__':
            iterator = Iterator(range(1, 5))
            print([i ** 2 for i in iterator])

-----
# 17 Builtin method
## 17.3 Membership test

        class MemberShip:
            def __init__(self, value):
                self.data = value
            def __contains__(self, item):
                print('contains: ', end='')
                return item in self.data
            def __iter__(self): # Fallback 1
                print('iter=> ', end='')
                self.ix = 0
                return self
            def __next__(self):
                print('next:', end='')
                if self.ix == len(self.data): raise StopIteration
                item = self.data[self.ix]
                self.ix += 1
                return item
            def __getitem__(self, item): # Fallback 2
                print(f'get[{item}]:', end='')
                return self.data[item]

        if __name__ == '__main__':
            x = MemberShip([1, 2, 3, 4, 5])
            print(3 in x)
            print([i ** 2 for i in x])

-----
# 17 Builtin method
## 17.4 Boolean test

        class BooleanDemo:

            def __init__(self, value):
                self.data = value

            def __bool__(self):
                print('__bool__:', end='')
                return False if self.data else True

            def __len__(self): # Fallback
                print('__len__:', end='')
                return 0 if self.data else 1

            def __gt__(self, other):
                print('__gt__:', end='')
                return self.data > other.data


        if __name__ == '__main__':
            zero, one  = BooleanDemo(0), BooleanDemo(1)
            print('true' if bd else 'false')
            print(one > zero)

-----
# 17. Builtin method
## 17.5 Call expressions

        class CallableInstanceClass:

            def __init__(self, name):
                print(f'calling class:<{self.__class__.__name__}>')
                self.name = name

            def __call__(self, *args, **kwargs):
                print(f'calling instance:<{self.name}>')


        if __name__ == '__main__':
            print('callable expression demo!')
            callable_instance = CallableInstanceClass('callable instance')
            callable_instance()
-----
# 17. Builtin method
## 17.6 Context manager

        class ContextManager:
            def __enter__(self):
                print('With:    ', end='')
                return self

            def __exit__(self, exc_type, exc_val, exc_tb):
                if not exc_type:
                    print(' exit ok!')
                else:
                    print(f' exit error: {exc_type}!' )
                    return True
            def work(self):
                print(':working:    ', end='')

        if __name__ == '__main__':
            with ContextManager() as cm:
                cm.work()

            with ContextManager() as cm:
                cm.work()
                raise ValueError('context error')

-----
# 17. Builtin method 
## 17.7 Extra builtin methods

* Boolean comparision: 

     `__eq__,__ne__, __gt__, __ge__, __lt__, __le__`
* Cusomize string representtion:

    `__str__, __repr__`
* Descturction method: 

    `__del__`

-----

# 18. Class design

* Class inheritance: **is-a**
* Class composition: **has-a**
* Class proxy: **agent**
* Extras:
    * Abstract Class
    * Static & Class method: (showed before)
    * Managed attribute: (showed before)
    * Decorators
    * Type subclasses & Meta classes

-----
# 18.1 Class inheritance 

        class Employee:
            def __init__(self, name=None, position=None, salary=None, department=None):
                self.name, self.position, self.salary, self.department = name, position, salary, department
        class EmployLevel:
            def __init__(self, salary):
                self.salary = salary
        class Junior(EmployLevel):
            def __init__(self):
                super().__init__(2000)
        class Full(EmployLevel):
            def __init__(self):
                super().__init__(3000)
        class Senior(EmployLevel):
            def __init__(self):
                super().__init__(4000)
        class Backend(Employee):
            def __init__(self, name):
                super().__init__(name=name, position='backend', department='engineer')
        class BackendJunior(Backend, Junior):
            def __init__(self, name):
                Backend.__init__(self, name)
                Junior.__init__(self)
        if __name__ == '__main__':
            alice = BackendJunior('alice')
            print(alice.name, alice.position, alice.department, alice.salary)

-----
# 18.2 Class composition

        import random
        class Po:
            def __init__(self, name):
                self.name = name
            def talk(self):
                print(f'PO==>{self.name}: talking issue')
        class Dev:
            def __init__(self, name):
                self.name = name
            def talk(self):
                print(f'DEV**>{self.name}: discuss issue')
            def vote(self):
                print(f'DEV-->{self.name}: vote issue: {random.randint(1, 21)}')
        class Room:
            def prepare(self):
                print('----prepare air condition\n----prepare tv\n')
        class PlanningEvent:
            def __init__(self, room, po, devs):
                self.room, self.po, self.devs = room, po, devs
            def start(self):
                self.room.prepare()
                self.po.talk()
                for dev in self.devs: dev.talk()
                for dev in self.devs: dev.vote()
        if __name__ == '__main__':
            event = PlanningEvent(Room(), Po('alice'), [Dev('bob'), Dev('lucy')])
            event.start()
-----
# 18.3 Class proxy

        class Dev:
            def __init__(self, name):
                self.name = name

            def internal_issue_handle(self, description):
                print(f'DEV:[{self.name}] handling internal issue: <{description}>')

        class Leader(Dev):
            def external_issue_handle(self, description):
                print(f'LEADER:[{self.name}] handling external issue: <{description}>')

        class Team: # proxy class 
            def __init__(self, leader, dev):
                self.leader = leader
                self.dev = dev

            def __getattr__(self, item):
                if item.startswith('external'):
                    return getattr(self.leader, item)
                if item.startswith('internal'):
                    return getattr(self.dev, item)
                return super(Team, self).__getattr__(item)

        if __name__ == '__main__':
            team = Team(Leader('alice'), Dev('bob'))
            team.external_issue_handle('product problem!') # LEADER:[alice] handling external issue: <product problem!>
            team.internal_issue_handle('bug problem!') # DEV:[bob] handling internal issue: <bug problem!>

-----
# 19. Class from scratch

        class_parents = (object, )
        class_name = 'Employee'
        class_attributes = {'name':'truckpader', 'salary':0}
        def bindable_work(self):
            print(f'{self.name} is working')
        def bindable_raise_salary(self, percent):
            self.salary *= (1.0+percent)
        def customized_init(self, name, salary=0):
            self.name = name 
            self.salary = salary
        def customized_str(self):
            return f'<{class_name}: name={self.name}, salary={self.salary}>'
        class_methods={
            '__init__':customized_init,
            'work':bindable_work, 
            'raise_salary':bindable_raise_salary, 
            '__str__':customized_str
        }
        # Create a class from the bottom with a collection of components
        MyClass = type(class_name, class_parents, {**class_attributes, **class_methods})
        
        if __name__ == "__main__":
            bob=MyClass('bob', 2000)
            print(bob)
            bob.work()
            bob.raise_salary(0.2)
            print(bob)

</div>


<div class="step slide markdown" data-rotate="-90" data-x="3500" data-y="2000" data-z="-1000" data-scale="4">

# 20. What else?

* Hacking python decorator & metaclass
* Hacking python iteration & comprehensions
* Hacking python builtin data types


</div>

<script type="text/javascript">
var enableBwCss = function(){
    disableDevopsCss();
    disableEffectsCss();
};

var enableDevopsCss = function(){
    document.body.classList.add("devopsy");
    disableEffectsCss();
};

var disableDevopsCss = function(){
    document.body.classList.remove("devopsy");
};

var enableEffectsCss = function(){
    document.body.classList.add("effects");
    disableDevopsCss();
};

var disableEffectsCss = function(){
    document.body.classList.remove("effects");
};
</script>


<div class="step slide markdown" data-rotate="0" data-x="6500" data-y="7000" data-z="-2000">

# Thanks

## Happy hacking python  
</div>


<div id="overview" class="step" data-x="5000" data-y="4000" data-scale="10" style="pointer-events: none;" data-rotate="5">
</div>

</div>

<div id="impress-toolbar"></div>
<div id="impress-help"></div>


<!-- Extra modules
     Load highlight.js, mermaid.js and markdown.js from extras.
     See also src/plugins/extras/extras.js -->
<script type="text/javascript" src="../../extras/highlight/highlight.pack.js"></script>
<script type="text/javascript" src="../../extras/mermaid/mermaid.min.js"></script>
<script type="text/javascript" src="../../extras/markdown/markdown.js"></script>
<!--
    To make all described above really work, you need to include impress.js in the page.
    You also need to call a `impress().init()` function to initialize impress.js presentation.
    And you should do it in the end of your document. 
-->
<script type="text/javascript" src="../../js/impress.js"></script>
<script>
    document.body.classList.add("effects");
    impress().init();
</script>
</body>
</html>
